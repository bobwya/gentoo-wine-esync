--- a/0045-server-ntdll-Implement-alertable-waits.patch	2018-11-01 17:19:43.000000000 +0000
+++ b/0045-server-ntdll-Implement-alertable-waits.patch	2020-04-29 20:41:36.955344616 +0100
@@ -73,12 +73,12 @@
 @@ -728,6 +752,8 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
  
          if (msgwait)
-             DPRINTF(" or driver events (fd %d)", ntdll_get_thread_data()->esync_queue_fd);
+             TRACE(" or driver events (fd %d)", ntdll_get_thread_data()->esync_queue_fd);
 +        if (alertable)
-+            DPRINTF(", alertable");
++            TRACE(", alertable");
  
          if (!timeout)
-             DPRINTF(", timeout = INFINITE.\n");
+             TRACE(", timeout = INFINITE.\n");
 @@ -766,10 +792,17 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
          }
          if (msgwait)
@@ -203,9 +203,9 @@
 index 0ce1f32b70..ca82a794bd 100644
 --- a/dlls/ntdll/ntdll_misc.h
 +++ b/dlls/ntdll/ntdll_misc.h
-@@ -236,6 +236,7 @@ struct ntdll_thread_data
-     BOOL               wow64_redir;   /* Wow64 filesystem redirection flag */
+@@ -286,6 +286,7 @@ struct ntdll_thread_data
      pthread_t          pthread_id;    /* pthread thread id */
+     void              *pthread_stack; /* pthread stack */
      int                esync_queue_fd;/* fd to wait on for driver events */
 +    int                esync_apc_fd;  /* fd to wait on for user APCs */
  };
@@ -223,14 +223,14 @@
  
      signal_init_thread( teb );
      virtual_init_threading();
-@@ -664,6 +665,7 @@ NTSTATUS WINAPI RtlCreateUserThread( HANDLE process, SECURITY_DESCRIPTOR *descr,
+@@ -835,6 +836,7 @@ NTSTATUS WINAPI RtlCreateUserThread( HANDLE process, SECURITY_DESCRIPTOR *descr,
      thread_data->wait_fd[1]  = -1;
      thread_data->start_stack = (char *)teb->Tib.StackBase;
      thread_data->esync_queue_fd = -1;
 +    thread_data->esync_apc_fd = -1;
  
-     pthread_attr_init( &attr );
-     pthread_attr_setstack( &attr, teb->DeallocationStack,
+     pthread_attr_init( &pthread_attr );
+     pthread_attr_setstack( &pthread_attr, teb->DeallocationStack,
 diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
 index d05441b1d3..25e2b897df 100644
 --- a/include/wine/server_protocol.h
@@ -269,17 +269,14 @@
  };
  union generic_reply
  {
-@@ -6617,8 +6630,9 @@ union generic_reply
+@@ -6900,6 +6913,7 @@ union generic_reply
      struct create_esync_reply create_esync_reply;
      struct open_esync_reply open_esync_reply;
      struct get_esync_fd_reply get_esync_fd_reply;
 +    struct get_esync_apc_fd_reply get_esync_apc_fd_reply;
  };
  
--#define SERVER_PROTOCOL_VERSION 573
-+#define SERVER_PROTOCOL_VERSION 574
  
- #endif /* __WINE_WINE_SERVER_PROTOCOL_H */
 diff --git a/server/esync.c b/server/esync.c
 index 6adf996872..8bf6e441f1 100644
 --- a/server/esync.c
@@ -390,9 +387,9 @@
      thread->token           = NULL;
      thread->esync_fd        = -1;
 +    thread->esync_apc_fd    = -1;
- 
-     thread->creation_time = current_time;
-     thread->exit_time     = 0;
+     thread->exit_poll       = NULL;
+     thread->shm_fd          = -1;
+     thread->shm             = NULL;
 @@ -289,7 +290,10 @@ struct thread *create_thread( int fd, struct process *process, const struct secu
      }
  
@@ -438,9 +435,9 @@
      struct token          *token;         /* security token associated with this thread */
      int                    esync_fd;      /* esync file descriptor (signalled on exit) */
 +    int                    esync_apc_fd;  /* esync apc fd (signalled when APCs are present) */
- };
- 
- struct thread_snapshot
+     struct timeout_user   *exit_poll;     /* poll if the thread/process has exited already */
+     int                    shm_fd;        /* file descriptor for thread local shared memory */
+     shmlocal_t            *shm;           /* thread local shared memory pointer */
 diff --git a/server/trace.c b/server/trace.c
 index 03c537d8ab..89c4743d3d 100644
 --- a/server/trace.c
