--- null	1970-01-01 01:00:00.000000000 +0100
+++ b/0087-ntdll-esync-Lock-accessing-the-shm_addrs-array.patch	2019-11-12 22:02:41.064737020 +0000
@@ -0,0 +1,49 @@
+From c1804983dc8e9509c088c35914212cda1bd5a48a Mon Sep 17 00:00:00 2001
+From: Zebediah Figura <zfigura@codeweavers.com>
+Date: Wed, 7 Aug 2019 17:14:54 -0500
+Subject: [PATCH] ntdll/esync: Lock accessing the shm_addrs array.
+---
+ dlls/ntdll/esync.c | 18 +++++++++++++++++-
+ 1 file changed, 17 insertions(+), 1 deletion(-)
+diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
+index 0adb4ad77..2f030c141 100644
+--- a/dlls/ntdll/esync.c
++++ b/dlls/ntdll/esync.c
+@@ -155,10 +155,22 @@ void esync_init(void)
+     shm_addrs_size = 128;
+ }
+ 
++static RTL_CRITICAL_SECTION shm_addrs_section;
++static RTL_CRITICAL_SECTION_DEBUG shm_addrs_debug =
++{
++    0, 0, &shm_addrs_section,
++    { &shm_addrs_debug.ProcessLocksList, &shm_addrs_debug.ProcessLocksList },
++      0, 0, { (DWORD_PTR)(__FILE__ ": shm_addrs_section") }
++};
++static RTL_CRITICAL_SECTION shm_addrs_section = { &shm_addrs_debug, -1, 0, 0, 0, 0 };
++
+ static void *get_shm( unsigned int idx )
+ {
+     int entry  = (idx * 8) / pagesize;
+     int offset = (idx * 8) % pagesize;
++    void *ret;
++
++    RtlEnterCriticalSection(&shm_addrs_section);
+ 
+     if (entry >= shm_addrs_size)
+     {
+@@ -180,7 +192,11 @@ static void *get_shm( unsigned int idx )
+             munmap( addr, pagesize ); /* someone beat us to it */
+     }
+ 
+-    return (void *)((unsigned long)shm_addrs[entry] + offset);
++    ret = (void *)((unsigned long)shm_addrs[entry] + offset);
++
++    RtlLeaveCriticalSection(&shm_addrs_section);
++
++    return ret;
+ }
+ 
+ /* We'd like lookup to be fast. To that end, we use a static list indexed by handle.
+-- 
+2.23.0
