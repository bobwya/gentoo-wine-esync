--- a/0045-server-ntdll-Implement-alertable-waits.patch	2018-11-01 17:19:43.000000000 +0000
+++ b/0045-server-ntdll-Implement-alertable-waits.patch	2019-04-27 22:44:21.138678322 +0100
@@ -2,9 +2,7 @@
 From: Zebediah Figura <z.figura12@gmail.com>
 Date: Fri, 15 Jun 2018 14:12:22 -0500
 Subject: [PATCH 45/83] server, ntdll: Implement alertable waits.
-
 We do this quite simply by waiting on an extra eventfd descriptor, which the server signals when a user APC is queued.
-
 Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
 ---
  dlls/ntdll/esync.c             | 94 +++++++++++++++++++++++++++++-----
@@ -19,7 +17,6 @@
  server/thread.h                |  1 +
  server/trace.c                 |  7 +++
  11 files changed, 146 insertions(+), 18 deletions(-)
-
 diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
 index 360a980db2..395c8d3366 100644
 --- a/dlls/ntdll/esync.c
@@ -73,12 +70,12 @@
 @@ -728,6 +752,8 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
  
          if (msgwait)
-             DPRINTF(" or driver events (fd %d)", ntdll_get_thread_data()->esync_queue_fd);
+             TRACE(" or driver events (fd %d)", ntdll_get_thread_data()->esync_queue_fd);
 +        if (alertable)
-+            DPRINTF(", alertable");
++            TRACE(", alertable");
  
          if (!timeout)
-             DPRINTF(", timeout = INFINITE.\n");
+             TRACE(", timeout = INFINITE.\n");
 @@ -766,10 +792,17 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
          }
          if (msgwait)
@@ -216,8 +213,8 @@
 --- a/dlls/ntdll/thread.c
 +++ b/dlls/ntdll/thread.c
 @@ -355,6 +355,7 @@ void thread_init(void)
+     thread_data->wait_fd[0] = -1;
      thread_data->wait_fd[1] = -1;
-     thread_data->debug_info = &debug_info;
      thread_data->esync_queue_fd = -1;
 +    thread_data->esync_apc_fd = -1;
  
@@ -269,17 +266,14 @@
  };
  union generic_reply
  {
-@@ -6617,8 +6630,9 @@ union generic_reply
+@@ -6900,6 +6913,7 @@ union generic_reply
      struct create_esync_reply create_esync_reply;
      struct open_esync_reply open_esync_reply;
      struct get_esync_fd_reply get_esync_fd_reply;
 +    struct get_esync_apc_fd_reply get_esync_apc_fd_reply;
  };
  
--#define SERVER_PROTOCOL_VERSION 573
-+#define SERVER_PROTOCOL_VERSION 574
  
- #endif /* __WINE_WINE_SERVER_PROTOCOL_H */
 diff --git a/server/esync.c b/server/esync.c
 index 6adf996872..8bf6e441f1 100644
 --- a/server/esync.c
@@ -434,8 +428,8 @@
 --- a/server/thread.h
 +++ b/server/thread.h
 @@ -90,6 +90,7 @@ struct thread
-     timeout_t              exit_time;     /* Thread exit time */
      struct token          *token;         /* security token associated with this thread */
+     struct list            kernel_object; /* list of kernel object pointers */
      int                    esync_fd;      /* esync file descriptor (signalled on exit) */
 +    int                    esync_apc_fd;  /* esync apc fd (signalled when APCs are present) */
  };
@@ -482,4 +476,3 @@
  static const struct
 -- 
 2.19.1
-
