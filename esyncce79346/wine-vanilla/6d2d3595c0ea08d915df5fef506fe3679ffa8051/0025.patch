--- a/0025-server-Create-eventfd-descriptors-for-device-manager.patch	2018-11-01 17:19:43.000000000 +0000
+++ b/0025-server-Create-eventfd-descriptors-for-device-manager.patch	2020-04-29 20:41:32.390362545 +0100
@@ -28,11 +28,11 @@
  
  /* IRP object */
  
-@@ -88,10 +89,12 @@ struct device_manager
-     struct object          obj;           /* object header */
-     struct list            devices;       /* list of devices */
-     struct list            requests;      /* list of pending irps across all devices */
-+    int                    esync_fd;      /* esync file descriptor */
+@@ -96,10 +97,12 @@ struct device_manager
+     struct list            requests;       /* list of pending irps across all devices */
+     struct irp_call       *current_call;   /* call currently executed on client side */
+     struct wine_rb_tree    kernel_objects; /* map of objects that have client side pointer associated */
++    int                    esync_fd;       /* esync file descriptor */
  };
  
  static void device_manager_dump( struct object *obj, int verbose );
@@ -82,28 +82,28 @@
 +        if (do_esync())
 +            close( manager->esync_fd );
      }
- }
  
-@@ -629,6 +645,9 @@ static struct device_manager *create_device_manager(void)
-     {
+     while ((ptr = list_head( &manager->requests )))
+@@ -637,6 +653,9 @@ static struct device_manager *create_device_manager(void)
          list_init( &manager->devices );
          list_init( &manager->requests );
+         wine_rb_init( &manager->kernel_objects, compare_kernel_object );
 +
 +        if (do_esync())
 +            manager->esync_fd = esync_create_fd( 0, 0 );
      }
      return manager;
  }
-@@ -735,6 +754,9 @@ DECL_HANDLER(get_next_device_request)
-             iosb->in_size = 0;
-             list_remove( &irp->mgr_entry );
-             list_init( &irp->mgr_entry );
+@@ -743,6 +762,9 @@ DECL_HANDLER(get_next_device_request)
+                 /* we already own the object if it's only on manager queue */
+                 if (irp->file) grab_object( irp );
+                 manager->current_call = irp;
 +
-+            if (do_esync() && list_empty( &manager->requests ))
-+                esync_clear( manager->esync_fd );
++                if (do_esync() && list_empty( &manager->requests ))
++                    esync_clear( manager->esync_fd );
+             }
+             else close_handle( current->process, reply->next );
          }
-     }
-     else set_error( STATUS_PENDING );
 -- 
 2.19.1
 
